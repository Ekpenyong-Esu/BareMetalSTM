#include "stm32f4xx.h"

#define DS_DEVICE_ADDRESS 0xD0

#define DS_REGISTER_ADDRESS 0x0

void I2C_Init() {
    // Enable the I2C1 peripheral clock
    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;

    // Configure the GPIO pins (SCL and SDA) for I2C
    // This example configures pins as GPIOB Pin 6 (SCL) and GPIOB Pin 9 (SDA).
    // You need to set the corresponding GPIO pins based on your hardware connection.

    // Configure SCL
    GPIOB->MODER &= ~(GPIO_MODER_MODER6_0 | GPIO_MODER_MODER6_1); // Clear bits
    GPIOB->MODER |= (GPIO_MODER_MODER6_1); // Set to alternate function mode
    GPIOB->AFR[0] |= (4 << (4 * 6)); // AF4 for I2C1_SCL

    // Configure SDA
    GPIOB->MODER &= ~(GPIO_MODER_MODER9_0 | GPIO_MODER_MODER9_1); // Clear bits
    GPIOB->MODER |= (GPIO_MODER_MODER9_1); // Set to alternate function mode
    GPIOB->AFR[1] |= (4 << (4 * (9 - 8))); // AF4 for I2C1_SDA

    // Set clock speed
    I2C1->CR2 &= ~I2C_CR2_FREQ;
    I2C1->CR2 |= (42 << 1); // Assuming a 42 MHz system clock

    // Configure I2C speed (Standard mode or Fast mode)
    I2C1->CCR = 180; // For 100 kHz (Standard mode)
    I2C1->TRISE = 43; // (Maximum rise time)

    // Enable I2C peripheral
    I2C1->CR1 |= I2C_CR1_PE;
}

void I2C_Write(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) {
    // Generate START condition
    I2C1->CR1 |= I2C_CR1_START;

    // Wait until the START condition is generated
    while (!(I2C1->SR1 & I2C_SR1_SB));

    // Send device address with Write bit (0)
    I2C1->DR = (deviceAddress << 1);

    // Wait until the address is sent
    while (!(I2C1->SR1 & I2C_SR1_ADDR));
    (void)I2C1->SR2; // Clear ADDR bit

    // Send the register address
    I2C1->DR = registerAddress;

    // Wait until the data register is empty
    while (!(I2C1->SR1 & I2C_SR1_TXE));

    // Send the data
    I2C1->DR = data;

    // Wait until the data is sent
    while (!(I2C1->SR1 & I2C_SR1_BTF));

    // Generate STOP condition
    I2C1->CR1 |= I2C_CR1_STOP;
}

uint8_t I2C_Read(uint8_t deviceAddress, uint8_t registerAddress) {
    // Generate START condition
    I2C1->CR1 |= I2C_CR1_START;

    // Wait until the START condition is generated
    while (!(I2C1->SR1 & I2C_SR1_SB));

    // Send device address with Write bit (0)
    I2C1->DR = (deviceAddress << 1);

    // Wait until the address is sent
    while (!(I2C1->SR1 & I2C_SR1_ADDR));
    (void)I2C1->SR2; // Clear ADDR bit

    // Send the register address
    I2C1->DR = registerAddress;

    // Wait until the data register is empty
    while (!(I2C1->SR1 & I2C_SR1_TXE));

    // Generate repeated START condition
    I2C1->CR1 |= I2C_CR1_START;

    // Wait until the repeated START condition is generated
    while (!(I2C1->SR1 & I2C_SR1_SB));

    // Send device address with Read bit (1)
    I2C1->DR = (deviceAddress << 1) | 1;

    // Wait until the address is sent
    while (!(I2C1->SR1 & I2C_SR1_ADDR));
    (void)I2C1->SR2; // Clear ADDR bit

    // Enable ACK bit
    I2C1->CR1 |= I2C_CR1_ACK;

    // Wait until the data register is not empty
    while (!(I2C1->SR1 & I2C_SR1_RXNE));

    // Generate STOP condition
    I2C1->CR1 |= I2C_CR1_STOP;

    // Read the data
    uint8_t data = I2C1->DR;

    return data;
}


int main()
{
	 uint8_t data_to_write = 0x42;
    // Initialize the system, GPIO, and other configurations

    I2C_Init();

    // Write to the DS RTC module
    I2C_Write(DS_DEVICE_ADDRESS, DS_REGISTER_ADDRESS, data_to_write);

    // Read from the DS RTC module
    uint8_t data = I2C_Read(DS_DEVICE_ADDRESS, DS_REGISTER_ADDRESS);

    // Continue with your application logic

    while (1) {
        // Your main application code here
    }
}
